= Docker and Kubernetes for Java EE Developers
:toc:
:toc-placement!:

## Preface
Containers are enabling developers to package their applications (and underlying dependencies) in new ways that are portable and work consistently everywhere? On your machine, in production, in your data center, and in the cloud. And Docker has become the de facto standard for those portable containers in the cloud.

Docker is the developer-friendly Linux container technology that enables creation of your stack: OS, JVM, app server, app, and all your custom configuration. So with all it offers, how comfortable are you and your team taking Docker from development to production? Are you hearing developers say, “But it works on my machine!” when code breaks in production?

This lab offers developers an intro-level, hands-on session with Docker, from installation, to exploring Docker Hub, to crafting their own images, to adding Java apps and running custom containers. It will also explain how to use Swarm to orchesorchestrate these containers together. This is a BYOL (bring your own laptop) session, so bring your Windows, OSX, or Linux laptop and be ready to dig into a tool that promises to be at the forefront of our industry for some time to come.

toc::[]

## Setup Environments

This section describes the relevant steps for both attendees and instructors to setup the environments. Please follow the parts, that are appropriate for you.

### Instructor

The instructor setup is designed to make the lab most reliable even with bad Internet connections. Most if not all of the software can be directly downloaded from the instructor's machine. The machine is setup as _Docker Host_ and also runs a _Docker Registry_.

Execute https://github.com/arun-gupta/docker-java/tree/master/instructor[instructor setup instructions] at least a day before the lab.

### Attendees

This lab is designed for a BYOL (Brying Your Own Laptop) style hands-on-lab. We did our best to support a wide range of client configurations but only did test on machines as stated in the hardware section.

https://github.com/arun-gupta/docker-java/tree/master/attendees[Download and setup attendee laptop].

## Docker Basics
Docker simplifies software delivery by making it easy to build and share images that contain your application’s entire environment, or application operating system.

**What does it mean by application operating system ?**

Your application typically require a specific version of operating system, application server, JDK, database server, may require to tune the configuration files, and similarly multiple other dependencies. The application may need binding to specific ports and certain amount of memory. The components and configuration together required to run your application is what is referred to as application operating system.

You can certainly provide an installation script that will download and install these components. Docker simplifies this process by allowing to create an image that contains your application and infrastructure together, managed as one component. These images are then used to create Docker containers which run on the container virtualization platform, provided by Docker.

**What can a Java Developer use Docker for?**

. *Faster delivery of your applications*: Docker helps you with the development lifecycle.
Docker allows you to develop on local containers that contain your applications
and services. It can then integrate into a continuous integration and
deployment workflow.
+
For example, you write code locally and share the development stack
via Docker with colleagues. When everybody is ready, you push the
code and the stack you all are developing onto a test environment
and execute any required tests.
+
From the testing environment, you can then push the Docker images
into production and deploy your code.
+
. *Deploying and scaling more easily*: Docker's container-based platform allows for portable workloads. Docker containers can run on a developer's local host, on physical
or virtual machines in a data center, or in the Cloud.
+
Docker's portability and lightweight nature also make dynamically managing workloads easy. You can use Docker to quickly scale up or tear down applications and services. Docker is so fast, that scaling can be near real time.

**How is it different from VM?**

Docker is an open source container virtualization platform.

Docker has three main components:

. __Images__ are *build component* of Docker and a read-only template of application operating system.
. __Containers__ are *run component* of Docker, and created from, images.Containers can be run, started, stopped, moved, and deleted.
. Images are stored, shared, and managed in a __registry__, the *distribution component* of Docker. The publically available registry is known as Docker Hub.

In order for these three components to work together, there is *Docker Daemon* that runs on a host machine and does the heavy lifting of building, running, and distributing Docker containers. In addition, there is *Client* that is a Docker binary which accepts commands from the user and communicates back and forth with the daemon.

.Docker architecture
image::images/docker-architecture.png[]

Client communicates with Daemon, either co-located on the same host, or on a different host. It requests the Daemon to pull an image from the repository using `pull` command. The Daemon then downloads the image from Docker Hub, or whatever registry is configured. Multiple images can be downloaded from the registry and installed on Daemon host. Images are run using `run` command to create containers on demand.

**How does a Docker Image work?**

We've already seen that Docker images are read-only templates from which Docker containers are launched. Each image consists of a series of layers. Docker makes use of union file systems to combine these layers into a single image. Union file systems allow files and directories of separate file systems, known as branches, to be transparently overlaid, forming a single coherent file system.

One of the reasons Docker is so lightweight is because of these layers. When you change a Docker image—for example, update an application to a new version— a new layer gets built. Thus, rather than replacing the whole image or entirely rebuilding, as you may do with a virtual machine, only that layer is added or updated. Now you don't need to distribute a whole new image, just the update, making distributing Docker images faster and simpler.

Every image starts from a base image, for example `ubuntu`, a base Ubuntu image, or `fedora`, a base Fedora image. You can also use images of your own as the basis for a new image, for example if you have a base Apache image you could use this as the base of all your web application images.

NOTE: By default, Docker obtains these base images from Docker Hub.

Docker images are then built from these base images using a simple, descriptive set of steps we call instructions. Each instruction creates a new layer in our image. Instructions include actions like:

. Run a command.
. Add a file or directory.
. Create an environment variable.
. What process to run when launching a container from this image.

These instructions are stored in a file called a Dockerfile. Docker reads this Dockerfile when you request a build of an image, executes the instructions, and returns a final image.

**How does a Container work?**

A container consists of an operating system, user-added files, and meta-data. As we've seen, each container is built from an image. That image tells Docker what the container holds, what process to run when the container is launched, and a variety of other configuration data. The Docker image is read-only. When Docker runs a container from an image, it adds a read-write layer on top of the image (using a union file system as we saw earlier) in which your application can then run.

## Docker Machine

Machine makes it really easy to create Docker hosts on your computer, on cloud providers and inside your own data center. It creates servers, installs Docker on them, then configures the Docker client to talk to them.

Once your Docker host has been created, it then has a number of commands for managing them:

. Starting, stopping, restarting
. Upgrading Docker
. Configuring the Docker client to talk to your host

You used Docker Machine already during the attendee setup. We won't need it too much further on. But if you need to create hosts, it's a very handy tool to know about. From now on we're mostly going to use the docker client.
Find out more about the details at the link:https://docs.docker.com/machine/[Official Docker Machine Website]

Check if docker machine is working using the following command:

[source, text]
----
docker-machine -v
----

## Docker Client

The client communicates with the demon process on your host and let's you work with images and containers.

Check if your client is working using the following command:

[source, text]
----
docker -v
----

The most important options you'll be using frequently are:

. `run` - runs a container
. `ps`- lists containers
. `stop` - stops a container

Get a full list of available commands with
[source, text]
----
docker
----

## Verify Docker Configuration

Check if your Docker Host is running:

[source, text]
----
docker-machine ls
----

You should see the output similar to:

[source, text]
----
NAME        ACTIVE   DRIVER       STATE     URL                         SWARM
lab                  virtualbox   Running   tcp://192.168.99.101:2376   
----

If the machine state is stopped, start it with:

[source, text]
----
docker-machine start lab
----

After it is started you can find out IP address of your host with:

[source, text]
----
docker-machine ip lab
----

We already did this during the setup document, remember? So, this is a good chance to check, if you already added this IP to your hosts file.

Type:

[source, text]
----
ping dockerhost
----

and see if this resolves to the IP address that the docker-machine command printed out. You should see an output as:

[source, text]
----
> ping dockerhost
PING dockerhost (192.168.99.101): 56 data bytes
64 bytes from 192.168.99.101: icmp_seq=0 ttl=64 time=0.394 ms
64 bytes from 192.168.99.101: icmp_seq=1 ttl=64 time=0.387 ms
----

If it does, you're ready to start over with the lab. If it does not, make sure you've followed the steps to https://github.com/arun-gupta/docker-java/tree/master/attendees#configure-host[configure your host].

## Running WildFly Container

The first step in running any application on Docker is to run an image. There are plenty of images available from the official Docker registry (aka link:https://hub.docker.com[Docker Hub]). To run any of them, you just have to ask the Docker Client to run it. The client will check if the image already exists on Docker Host. If it exists then it'll run it, otherwise the host will download the image and then run it.

### Pull Image

Let's first check, if there are any images already available:

[source, text]
----
docker images
----

At first, this list is empty. Now, let's get a plain `jboss/wildfly` image from the instructor's registry:

[source, text]
----
docker pull <INSTRUCTOR_IP>:5000/wildfly
----

By default, docker images are retrieved from https://hub.docker.com/[Docker Hub]. This lab is pre-congfigured to run such that everything can be pulled from instructor's machine.

You can see, that Docker is downloading the image with it's different layers.

[NOTE]
====
In a traditional Linux boot, the Kernel first mounts the root File System as read-only, checks its integrity, and then switches the whole rootfs volume to read-write mode.
When Docker mounts the rootfs, it starts read-only, as in a traditional Linux boot, but then, instead of changing the file system to read-write mode, it takes advantage of a union mount to add a read-write file system over the read-only file system. In fact there may be multiple read-only file systems stacked on top of each other. Consider each one of these file systems as a layer.

At first, the top read-write layer has nothing in it, but any time a process creates a file, this happens in the top layer. And if something needs to update an existing file in a lower layer, then the file gets copied to the upper layer and changes go into the copy. The version of the file on the lower layer cannot be seen by the applications anymore, but it is there, unchanged.

We call the union of the read-write layer and all the read-only layers a _union file system_.

.Docker Layers
image::images/plain-wildfly0.png[]
====

In our particular case, the https://github.com/jboss-dockerfiles/wildfly/blob/master/Dockerfile[jboss/wildfly] image extends the link:https://github.com/jboss-dockerfiles/base/blob/master/Dockerfile[jboss/base-jdk:7] image which adds the OpenJDK distribution on top of the link:https://github.com/jboss-dockerfiles/base/blob/master/Dockerfile[jboss/base] image.
The base image is used for all JBoss community images. It provides a base layer that includes:

. A jboss user (uid/gid 1000) with home directory set to `/opt/jboss`
. A few tools that may be useful when extending the image or installing software, like unzip.

The ``jboss/base-jdk:7'' image adds:

. Latest OpenJDK distribution
. Adds a JAVA_HOME environment variable

When the download is done, you can list the images again and will see the following:

[source, text]
----
docker images

REPOSITORY              TAG     IMAGE ID       CREATED       VIRTUAL SIZE
<INSTRUCTOR_IP>:5000/wildfly  latest  2ac466861ca1   10 weeks ago  951.3 MB
----

### Run Container

#### Interactive Container

Run WildFly container in an interactive mode.

[source, text]
----
docker run -it <INSTRUCTOR_IP>:5000/wildfly
----

This will show the output as:

[source, text]
----
> docker run -it 192.168.99.100:5000/wildfly
=========================================================================

  JBoss Bootstrap Environment

  JBOSS_HOME: /opt/jboss/wildfly

  JAVA: /usr/lib/jvm/java/bin/java

  JAVA_OPTS:  -server -Xms64m -Xmx512m -XX:MaxPermSize=256m -Djava.net.preferIPv4Stack=true -Djboss.modules.system.pkgs=org.jboss.byteman -Djava.awt.headless=true

=========================================================================

17:58:58,353 INFO  [org.jboss.modules] (main) JBoss Modules version 1.3.3.Final
17:58:58,891 INFO  [org.jboss.msc] (main) JBoss MSC version 1.2.2.Final
17:58:59,056 INFO  [org.jboss.as] (MSC service thread 1-2) JBAS015899: WildFly 8.2.0.Final "Tweek" starting

. . .

17:59:03,211 INFO  [org.jboss.as] (Controller Boot Thread) JBAS015961: Http management interface listening on http://127.0.0.1:9990/management
17:59:03,212 INFO  [org.jboss.as] (Controller Boot Thread) JBAS015951: Admin console listening on http://127.0.0.1:9990
17:59:03,213 INFO  [org.jboss.as] (Controller Boot Thread) JBAS015874: WildFly 8.2.0.Final "Tweek" started in 5310ms - Started 184 of 234 services (82 services are lazy, passive or on-demand)
----

This shows that the server started correctly, congratulations!

By default, Docker runs in the foreground. `-i` allows to interact with the STDIN and `-t` attach a TTY to the process. Switches can be combined together and used as `-it`.

Hit Ctrl+C to stop the container.

#### Detached Container

Restart the container in detached mode:

[source, text]
----
> docker run -d 192.168.99.100:5000/wildfly
972f51cc8422eec0a7ea9a804a55a2827b5537c00a6bfd45f8646cb764bc002a
----

`-d` runs the container in detached mode.

The output is the unique id assigned to the container. Check the logs as:

[source, text]
----
> docker logs 972f51cc8422eec0a7ea9a804a55a2827b5537c00a6bfd45f8646cb764bc002a
=========================================================================

  JBoss Bootstrap Environment

  JBOSS_HOME: /opt/jboss/wildfly

. . .
----

We can check it by issuing the `docker ps` command which retrieves the images process which are running and the ports engaged by the process:

[source, text]
----
> docker ps
CONTAINER ID        IMAGE                                 COMMAND                CREATED             STATUS              PORTS                    NAMES
0bc123a8ece0        192.168.99.100:5000/wildfly:latest    "/opt/jboss/wildfly/   4 seconds ago       Up 4 seconds        8080/tcp                 tender_wozniak 
----

Also try `docker ps -a` to see all the containers on this machine.

### Run Container with Default Port

Startup log of the server shows that the server is located in the `/opt/jboss/wildfly`. It also shows that the public interfaces are bound to the `0.0.0.0` address while the admin interfaces are bound just to `localhost`. This information will be useful to learn how to customize the server.

`docker-machine ip <machine-name>` gives us the Docker Host IP address and this was already added to the hosts file. So, we can give it another try by accessing: http://dockerhost:8080. However, this will not work either.

If you want containers to accept incoming connections, you will need to provide special options when invoking `docker run`. The container, we just started, can't be accessed by our browser. We need to stop it again and restart with different options.

[source, text]
----
docker stop 0bc123a8ece0
----

Restart the container as:

[source, text]
----
> docker ps
CONTAINER ID        IMAGE                                 COMMAND                CREATED             STATUS              PORTS                     NAMES
4545ced66242        192.168.99.100:5000/wildfly:latest    "/opt/jboss/wildfly/   3 seconds ago       Up 3 seconds        0.0.0.0:32768->8080/tcp   suspicious_wozniak   
----

`-P` flag map any network ports inside the image it to a random high port from the range 49153 to 65535 on Docker host.

The port mapping is shown in the `PORTS` column. Access the WildFly server at http://dockerhost:32768:8080. Make sure to use the correct port number as shown in your case.

### Run Container with Specified Port

Lets stop the previously running container as:

[source, text]
----
docker stop 4545ced66242
----

Restart the container as:

[source, text]
----
docker run -it -p 8080:8080 <INSTRUCTOR_IP>:5000/wildfly
----

The format is `-p hostPort:containerPort`. This option maps container ports to host ports and allows other containers on our host to access them.

.Docker Port Mapping
[NOTE]
===============================
Port exposure and mapping are the keys to successful work with Docker.
See more about networking on the Docker website link:https://docs.docker.com/articles/networking/[Advanced Networking]
===============================

Now we're ready to test http://dockerhost:8080 again. This works with the exposed port, as expected.

.Welcome WildFly
image::images/plain-wildfly1.png[]

### Enabling WildFly Administration

Default WildFly image exposes only port 8080 and thus is not available for administration using either the CLI or Admin Console.

#### Default Port Mapping

The following command will override the default command in Docker file, explicitly starting WildFly, and binding application and management port to all network interfaces.

[source, text]
----
docker run -P -d <INSTRUCTOR_IP>:5000/wildfly /opt/jboss/wildfly/bin/standalone.sh -b 0.0.0.0 -bmanagement 0.0.0.0
----

Accessing WildFly Administration Console require a user in administration realm. A pre-created image, with appropriate username/password credentials, is used to start WildFly as:

[source, text]
----
docker run -P -d 192.168.99.100:5000/wildfly-management
----

`-P` flag map any network ports inside the image it to a random high port from the range 49153 to 65535 on Docker host.

Look at the exposed ports as:

[source, text]
----
 docker ps
CONTAINER ID        IMAGE                                           COMMAND                CREATED             STATUS              PORTS                                              NAMES
6f610b310a46        192.168.99.100:5000/wildfly-management:latest   "/bin/sh -c '/opt/jb   6 seconds ago       Up 6 seconds        0.0.0.0:32769->8080/tcp, 0.0.0.0:32770->9990/tcp   determined_darwin 
----

Look for the host port that is mapped in the container, `32770` in this case. Access the admin console at http://dockerhost:32770.

The username/password credentials are:

[[WildFly_Administration_Credentials]]
[options="header"]
|====
| Field | Value
| Username | admin
| Password | docker#admin
|====

##### Additional Ways To Find Port Mapping

The exact mapped port can also be found as:

. Using `docker inspect`:
+
[source, text]
----
docker inspect --format='{{(index (index .NetworkSettings.Ports "9990/tcp") 0).HostPort}}' 6f610b310a46
----
+
. Using `docker port`:
+
[source, text]
----
docker port 6f610b310a46
----
+
to see the output as:
+
[source, text]
----
0.0.0.0:32769->8080/tcp
0.0.0.0:32770->9990/tcp
----

[[Fixed_Port_Mapping]]
#### Fixed Port Mapping

This management image can also be started with a pre-defined port mapping as:

[source, text]
----
docker run -p 8080:8080 -p 9990:9990 -d 192.168.99.100:5000/wildfly-management
----

In this case, Docker port mapping will be shown as:

[source, text]
----
8080/tcp -> 0.0.0.0:8080
9990/tcp -> 0.0.0.0:9990
----

### Stop and Remove Container

#### Stop Container

. Stop a specific container:
+
[source, text]
----
docker stop 0bc123a8ece0
----
+
. Stop all the running containers
+
[source, text]
----
docker rm $(docker stop $(docker ps -q))
----
+
. Stop only the exited containers
+
[source, text]
----
docker ps -a -f "exited=-1"
----

#### Remove Container

. Remove a specific container:
+
[source, text]
----
docker rm 0bc123a8ece0
----
+
. Containers meeting a regular expression
+
[source, text]
----
docker ps -a | grep wildfly | awk '{print $1}' | xargs docker rm
----
+
. All running containers, without any criteria
+
[source, text]
----
docker rm $(docker ps -aq)
----

Common Docker commands are available in link:command-cheatsheet.adoc[Docker Command Cheatsheet].

## Deploy Java EE 7 Application (Pre-Built WAR)

https://github.com/javaee-samples/javaee7-hol[Java EE 7 Hands-on Lab] has been delivered all around the world and is a pretty standard application that shows design patterns and anti-patterns for a typical Java EE 7 application.

.Java EE 7 Application Architecture
image::images/javaee7-hol.png[]

Pull the Docker image that contains WildFly and pre-built Java EE 7 application WAR file as shown:

[source, text]
----
docker pull <INSTRUCTOR_IP>:5000/javaee7-hol
----

The javaee7-hol link:https://github.com/arun-gupta/docker-images/blob/master/javaee7-hol/Dockerfile[Dockerfile] is based on `jboss/wildfly` and adds the movieplex7 application as war file.

Run it as:

[source, text]
----
docker run -it -p 8080:8080 <INSTRUCTOR_IP>:5000/javaee7-hol
----

See the application in action at http://dockerhost:8080/movieplex7/.

Only two changes are required to the standard `jboss/wildfly` image:

. Start WildFly in full platform:
+
[source, text]
----
CMD ["/opt/jboss/wildfly/bin/standalone.sh", "-c", "standalone-full.xml", "-b", "0.0.0.0"]
----
+
. WAR file is copied to `standalone/deployments` directory as:
+
[source, text]
----
RUN curl -L https://github.com/javaee-samples/javaee7-hol/blob/jrebel/solution/movieplex7-1.0-SNAPSHOT.war?raw=true -o /opt/jboss/wildfly/standalone/deployments/movieplex7-1.0-SNAPSHOT.war
----

## Build and Deploy Java EE 6 Application (Ticket Monster)

TicketMonster is an example application that focuses on Java EE6 - JPA 2, CDI, EJB 3.1 and JAX-RS along with HTML5 and jQuery Mobile. It is a moderately complex application that demonstrates how to build modern web applications optimized for mobile & desktop. TicketMonster is representative of an online ticketing broker - providing access to events (e.g. concerts, shows, etc) with an online booking application.

Apart from being a demo, TicketMonster provides an already existing application structure that you can use as a starting point for your app. You could try out your use cases, test your own ideas, or, contribute improvements back to the community.

.TicketMonster architecture
image::images/ticket-monster_tutorial_architecture.png[]

The application uses Java EE 6 services to provide business logic and persistence, utilizing technologies such as CDI, EJB 3.1 and JAX-RS, JPA 2. These services back the user-facing booking process, which is implemented using HTML5 and JavaScript, with support for mobile devices through jQuery Mobile.

The administration site is centered around CRUD use cases, so instead of writing everything manually, the business layer and UI are generated by Forge, using EJB 3.1, CDI and JAX-RS. For a better user experience, Twitter Bootstrap is used.

Monitoring sales requires staying in touch with the latest changes on the server side, so this part of the application will be developed in HTML5 and JavaScript using a polling solution.

[[Build_Application]]
### Build Application

First thing, you're going to do is to build the application from source. Create a directory for the source and change to it:

[source, text]
----
mkdir docker-java/
cd docker-java/
----

And checkout the sources from the instructor's git repository.

[source, text]
----
git clone -b WildFly-docker-test http://root:dockeradmin@<INSTRUCTOR_IP>:10080/root/ticket-monster.git
----

`-b WildFly-docker-test` is a branch of Ticket Monster that contains a ``docker-test'' profile to run Arquillian Cube test. More on this later.

NOTE: You're free to explore the application. Open it with with the favorite IDE of your choice. Find more background about the use-cases and how the application is designed at http://www.jboss.org/ticket-monster/whatisticketmonster/[Ticket Monster Website].

Copy the Maven lab-settings.xml file that you have downloaded from the instructor machine and place it inside `docker-java` directory.

NOTE: Make sure <INSTRUCTOR_IP> in `lab-settings.xml` is changed to match the IP address of instructor's machine.

When you're ready, it is time to build the application. Switch to the checkout directory and run maven package.

[source, text]
----
cd docker-java/
mvn -s lab-settings.xml -f ticket-monster/demo/pom.xml -Ppostgresql clean package
----

Congratulations! You just build the applications war file. Let's deploy it!

### Start Database Server

The application require an application server and a database server. This lab will use WildFly and Postgres for them respectively.

Start Postgres database as:

[source, text]
----
docker run --name db -d -p 5432:5432 -e POSTGRES_USER=ticketmonster -e POSTGRES_PASSWORD=ticketmonster-docker <INSTRUCTOR_IP>:5000/postgres
----

This command starts a container named ``db'' from the image in your instructor's registry `<INSTRUCTOR_IP>:5000/postgres`. As this will not be present locally, it needs to be downloaded first. But you'll have a very quick connection to the instructor registry and this shouldn't take long.

The two `-e` options define environment variables which are read by the db at startup and allow us to access the database with this user and password.

Finally, the `-d` option tells docker to start a demon process. Which means, that the console window, you're running this command in, will be available again after it is issued. If you skip this parameter, the console will be directly showing the output from the process.

`-p` option maps container ports to host ports and allows other containers on our host to access them.

This starts the database container. It can be confirmed as:

[source, text]
----
> docker ps
CONTAINER ID        IMAGE                                           COMMAND                CREATED             STATUS              PORTS                                              NAMES
047bab6a86fe        192.168.99.100:5000/postgres:latest             "/docker-entrypoint.   42 seconds ago      Up 3 seconds        0.0.0.0:5432->5432/tcp                             db   
----

Server logs can be viewed as:

[source, text]
----
docker logs -f db
----

The `-f` flag keeps refreshing the logs and pushes new events directly out to the console.

### Start Application Server

Start WildFly server as:

[source, text]
----
docker run -d --name wildfly -p 8080:8080 --link db:db -v /Users/youruser/tmp/deployments:/opt/jboss/wildfly/standalone/deployments/:rw <INSTRUCTOR_IP>:5000/wildfly
----

Make sure to replace `/Users/youruser/tmp/deployments` to a directory on your local machine. Also, make sure this directory already exists.

This command starts a container named ``wildfly''. `--link` takes two parameters - first is name of the container we're linking to and second is the alias for the link name.

.Container Linking
[NOTE]
===============================
Creating a link between two containers creates a conduit between a source container and a target container and securely transfer information about source container to target container.

In our case, target container (WildFly) can see information about source container (Postgres). When containers are linked, information about a source container can be sent to a recipient container. This allows the recipient to see selected data describing aspects of the source container.

See more about container communication on the Docker website link:https://docs.docker.com/userguide/dockerlinks/[Linking Containers Together]
===============================

The `-v` flag maps a directory from the host into the container. This will be the directory to put the deployments. `rw` ensures that the Docker container can write to it.

WARNING: Windows users, please make sure to use `-v /c/Users/` notation for drive letters.

Check logs to verify if the server has started.

[source, text]
----
docker logs -f wildfly
----

And access the http://dockerhost:8080 with your webbrowser to make sure the instance is up and running.

Now you're ready to deploy the application for the first time. Let's use JBoss Developer Studio for this.

### Configure JBoss Developer Studio

Start JBoss Developer Studio, if not already started.

. Create a server adapter
+
.Server adapter
image::images/jbds1.png[]
+
. Assign or create a WildFly 8.x runtime (changed properties are highlighted.)
+
.WildFly Runtime Properties
image::images/jbds2.png[]
+
. Setup server properties as shown in the following image.
+
Two properties on the left are automatically propagated from the previous dialog. Additional two properties on the right side are required to disable to keep deployment scanners in sync with the server.
+
.Server properties
image::images/jbds3.png[]
+
. Specify a custom deployment folder on Deployment tab of Server Editor
+
.Server Editor
image::images/jbds4.png[]
+
. Right-click on the newly created server adapter and click ``Start''.
+
.Start Server
image::images/jbds5.png[]

### Deploy Application Using Shared Volumes

Open Ticket Monster application source code. Right-click on the project, select ``Run on Server'' and chose the previously created server.

The project runs and displays the start page of Ticket Monster application.

.Start Server
image::images/jbds6.png[]

Congratulations! You've just deployed your first application to WildFly running in a Docker container from JBoss Developer Studio.

Stop WildFly container when you're done.

[source, text]
----
docker stop wildfly
----

### Deploy Application Using CLI (OPTIONAL)

The Command Line Interface (CLI) is a tool for connecting to WildFly instances to manage all tasks from command line environment. Some of the tasks that you can do using the CLI are:

. Deploy/Undeploy web application in standalone/Domain Mode.
. View all information about the deployed application on runtime.
. Start/Stop/Restart Nodes in respective mode i.e. Standalone/Domain.
. Adding/Deleting resource or subsystems to servers.

Lets use the CLI to deploy Ticket Monster to WildFly running in the container.

. CLI needs to be locally installed and comes as part of WildFly. Download WildFly 8.2 from http://<INSTRUCTOR_IP>:8082/downloads/wildfly-8.2.0.Final.zip. Unzip into a folder of your choice (e.g. `/Users/arungupta/tools/`). This will create `wildfly-8.2.0.Final` directory here. This folder is named $WIDLFY_HOME from here on. Make sure to add the `/Users/arungupta/tools/wildfly-8.2.0.Final/bin` to your $PATH.
+
[source, text]
----
# Windows Example
set PATH=%PATH%;%WILDFLY_HOME%/bin
----
+
. Run the ``wildfly-management'' image with fixed port mapping as explained in <<Fixed_Port_Mapping>>.
. Run the `jboss-cli` command and connect to the WildFly instance.
+
[source, text]
----
cd %WIDLFY_HOME%/bin
./jboss-cli.sh --controller=dockerhost:9990  -u=admin -p=docker#admin -c
----
+
This will show the output as:
+
[source, text]
----
[standalone@dockerhost:9990 /]
----
+
. Deploy the application as:
+
[source, text]
----
deploy <TICKET_MONSTER_PATH>/ticket-monster.war --force
----

Now you've sucessfully used the CLI to remote deploy the Ticket Monster application to WildFly running as docker container.

And again, keep the container running, we're going to look into the last deployment option you have.

### Deploy Application Using Web Console (OPTIONAL)

WildFly comes with a web-based administration console. It also relies on the same management APIs that we've already been using via JBoss Developer Tools and the CLI. It does provide a nice web-based way to administrate your instance and if you've already exposed the container ports, you can simply access it via the URL: http://dockerhost:9990 in your web browser.

.WildFly Web Console
image::images/console1.png[]

Username and password credentials are shown in <<WildFly_Administration_Credentials>>. Now navigate through the console and execute the following steps to deploy the application:

. Go to the ``Deployments'' tab.
. Click on ``Add'' button.
. On ``Step 1/2: Deployment Selection'' screen, select the <TICKET_MONSTER_PATH>/ticket-monster.war file on your computer and click ``Next''. This would be `ticket-monster/demo/target/ticket-monster.war` from <<Build_Application>>.
. On the ``Step 2/2: Verify Deployment Names'' screen, select ``Enable'' checkbox, and click on ``Save''.

This will complete the deployment of Ticket Monster using Admin Console.

### Deploy Application Using Management API (OPTIONAL)

A standalone WildFly process, process can be configured to listen for remote management requests using its ``native management interface''. The CLI tool that comes with the application server uses this interface, and user can develop custom clients that use it as well. In order to use this, WildFly management interface listen IP needs to be changed from 127.0.0.1 to 0.0.0.0 which basically means, that it is not only listening on the localhost but also on all publicly assigned IP addresses.

. Start another WildFly instance again:
+
[source, text]
----
docker run -d --name wildflymngm -p 8080:8080 -p 9990:9990 --link db:db <INSTRUCTOR_IP>:5000/wildfly-management
----
+
There is no mapped volume in this case but an additional port exposed. The WildFly image that is used makes it easier for you to play around with the deployment via the management API. It has a tweaked start script which changes the management interface according to the behavior described in the first sentence.
+
. Create another new server adapter in JBoss Developer Studio.
+
.Create New Server Adapter
image::images/jbds7.png[]
+
. Keep the defaults in the adapter properties.
+
.Adapter Properties
image::images/jbds8.png[]
+
. Set up server properties by specifying the admin credentials (docker#admin). Note, you need to delete the existing password and use this instead:
+
.Management Login Credentials
image::images/jbds9.png[]
+
. Right-click on the newly created server adapter and click ``Start''. Status quickly changes to ``Started, Synchronized'' as shown.
+
.Synchronized WildFly Server
image::images/jbds10.png[]
+
. Right-click on the Ticket Monster project, select ``Run on Server'' and choose this server. The project runs and displays the start page of ticket-monster.
. Stop WildFly when you're done.
+
[source, text]
----
docker stop wildflymngm
----

## Docker Maven Plugin

http://blog.arungupta.me/javaee-docker-maven-plugin/

## Docker Tools in Eclipse

The Docker tooling is aimed at providing at minimum the same basic level features as the command-line interface, but also provide some advantages by having access to a full fledged UI.

### Install Docker Tools Plugins

As this is still in early access stage, you will have to install it first:

. Download and Install https://devstudio.redhat.com/9.0/snapshots/builds/devstudio.product_master/latest/installer/[JBoss Developer Studio 9.0 Nightly], take defaults through out the installation. 
+
Alternatively, download http://www.eclipse.org/downloads/index-developer-default.php[Eclipse Mars latest build] and configure JBoss Tools plugin from the update site http://download.jboss.org/jbosstools/updates/nightly/mars/.
+
. Open JBoss Developer Studio 9.0 Nightly
. Add a new site using the menu items: ``Help'' > ``Install New Software...'' > ``Add...''. Specify the ``Name:'' as ``Docker Nightly'' and ``Location:'' as http://download.eclipse.org/linuxtools/updates-docker-nightly/.
+
.Add Docker Tooling To JBoss Developer Studio
image::images/jbds-docker-tools1.png[]
+
. Expand Linux Tools, select ``Docker Client'' and ``Docker Tooling''.
+
.Add Docker Tooling
image::images/jbds-docker-tools-nightly-setup.png[]
+
. Click on ``Next >'', ``Next >'', accept the terms of the license agreement, and click on ``Finish''. This will complete the installation of plugins.
+
Restart the IDE for the changes to take effect.

### Docker Explorer

The Docker Explorer provides a wizard to establish a new connection to a Docker daemon. This wizard can detect default settings if the user’s machine runs Docker natively (such as in Linux) or in a VM using Boot2Docker (such as in Mac or Windows). Both Unix sockets on Linux machines and the REST API on other OSes are detected and supported. The wizard also allows remote connections using custom settings.

. Use the menu ``Window'', ``Show View'', ``Other...''. Type ``docker'' to see the output as:
+
image::images/jbds-docker-tools-docker-view.png[]
+
. Select ``Docker Explorer'' to open Docker Explorer.
+
image::images/jbds-docker-tools-docker-explorer-view.png[]
+
. Click on the link in this window to create a connection to Docker Host. Specify the settings as shown:
+
.Docker Explorer
image::images/jbds-docker-tools2.png[]
+
Make sure to get IP address of the Docker Host as:
+
[source, text]
----
docker-machine ip lab
----
+
Also, make sure to specify the correct directory for `.docker` on your machine.
+
. Click on ``Test Connection'' to check the connection. This should show the output as:
+
.Docker Explorer
image::images/jbds-docker-tools-test-connection-output.png[]
+
Click on ``OK'' and ``Finish'' to exit out of the wizard.
+
. Docker Explorer itself is a tree view that handles multiple connections and provides users with quick overview of the existing images and containers.
+
.Docker Explorer Tree View
image::images/jbds-docker-tools3.png[]
+
. Customize the view by clicking on the arrow in toolbar:
+
.Docker Explorer Customize View
image::images/jbds-docker-tools-customize-view-option.png[]
+
Built-in filters can show/hide intermediate and `dangling' images, as well as stopped containers.
+
.Docker Explorer Customize View Wizard
image::images/jbds-docker-tools-customize-view-wizard.png[]

### Docker Images

The Docker Images view lists all images in the Docker host selected in the Docker Explorer view. This view allows user to manage images, including:

. Pull/push images from/to the Docker Hub Registry (other registries will be supported as well, https://bugs.eclipse.org/bugs/show_bug.cgi?id=469306[#469306])
. Build images from a Dockerfile
. Create a container from an image

Lets take a look at it.

. Use the menu ``Window'', ``Show View'', ``Other...'', select ``Docker Images''. It shows the list of images on Docker Host:
+
.Docker Images View
image::images/jbds-docker-tools4.png[]
+
. Right-click on the image ending with ``wildfly:latest'' and click on the green arrow in the toolbar. This will show the following wizard:
+
.Docker Run Container Wizard
image::images/jbds-docker-tools-run-container-wizard.png[]
+
By default, all exports ports from the image are mapped to random ports on the host interface. This setting can be changed by unselecting the first checkbox and specify exact port mapping.
+
Click on ``Finish'' to start the container.
+
. When the container is started, all logs are streamed into Eclipse Console:
+
.Docker Container Logs
image::images/jbds-docker-tools5.png[]

### Docker Containers

Docker Containers view lets the user manage the containers. The view toolbar provides commands to start, stop, pause, unpause, display the logs and kill containers.

. Use the menu ``Window'', ``Show View'', ``Other...'', select ``Docker Containers''. It shows the list of running containers on Docker Host:
+
.Docker Containers View
image::images/jbds-docker-tools6.png[]
+ 
. Pause the container by clicking on the ``pause'' button in the toolbar (https://bugs.eclipse.org/bugs/show_bug.cgi?id=[#469310]). Show the complete list of containers by clicking on the ``View Menu'', ``Show all containers''.
+
.All Docker Containers
image::images/jbds-docker-tools-all-containers.png[]
+
. Select the paused container, and click on the green arrow in the toolbar to restart the container.
. Right-click on any running container and select ``Display Log'' to view the log for this container.
+
.Eclipse Properties View
image::images/jbds-docker-tools-display-log.png[]

TODO: Users can also attach an Eclipse console to a running Docker container to follow the logs and use the STDIN to interact with it.

### Information and Inspect on Images and Containers

Eclipse Properties view is used to provide more information about the containers and images.

. Just open the Properties View and click on a Connection, Container, or Image in any of the Docker Explorer View, Docker Containers View, or Docker Images View. This will fill in data in the Properties view.
+
Info view is shown as:
+
.Docker Container Properties View Info
image::images/jbds-docker-tools-properties-info.png[]
+
Inspect view is shown as:
+
.Docker Container Properties View Inspect
image::images/jbds-docker-tools-properties-inspect.png[]

## Docker Tools in NetBeans

## Docker Tools in IntelliJ

http://blog.jetbrains.com/idea/2015/03/docker-support-in-intellij-idea-14-1/

## Test Java EE Applications on Docker

Testing Java EE applications is a very important aspect. Especially when it comes to in-container tests, link:http://www.arquillian.org[JBoss Arquillian] is well known to make this very easy.
Picking up where unit tests leave off, Arquillian handles all the plumbing of container management, deployment and framework initialization so you can focus on the task at hand, writing your tests. Real tests.

Arquillian brings the test to the runtime so you don’t have to manage the runtime from the test (or the build). Arquillian eliminates this burden by covering all aspects of test execution, which entails:

. Managing the lifecycle of the container(s)
. Bundling the test case, dependent classes and resources into a ShrinkWrap archive (or archives)
. Deploying the archive (or archives) to the container (or containers)
. Enriching the test case by providing dependency injection and other declarative services
. Executing the tests inside (or against) the container
. Capturing the results and returning them to the test runner for reporting
. To avoid introducing unnecessary complexity into the developer’s build environment, Arquillian integrates seamlessly with familiar testing frameworks (e.g., JUnit 4, TestNG 5), allowing tests to be launched using existing IDE, Ant and Maven test plugins — without any add-ons.

Basically, you can just use Arquillian with the link:http://arquillian.org/modules/wildfly-arquillian-wildfly-remote-container-adapter/[WildFly Remote container adapter] and connect to any WildFly instance running in a Docker container. But this wouldn't help with the Docker container lifycycle management.
This is where a new Arquillian extension, named link:http://arquillian.org/blog/2014/11/17/arquillian-cube-1-0-0-Alpha1/["Cube"] comes in.
With this extension you can start a Docker container with a server installed, deploy the required deployable file within it and execute Arquillian tests.

The key point here is that if Docker is used as deployable platform in production, your tests are executed in a the same container as it will be in production, so your tests are even more real than before.

[source, text]
----
mvn -s settings.xml -f ticket-monster/demo/pom.xml -Pdocker-test test
----

http://blog.arungupta.me/run-javaee-tests-wildfly-docker-arquillian-cube/

[[JavaEE_Application_Docker_Cluster]]
## Java EE Application on Container Cluster

A frequent requirement for Java EE based applications is running them on a cluster of application server. While setup and test can be complicated on developer machines, this is where Docker can play to it's full potential. With the help of images and automatic port mapping, we're ready to test Ticket Monster on a couple of WildFly instances and add and remove them randomly.

The diagram below shows what will be achieved in this section:

.Standalone Cluster with WildFly and mod_cluster
image::images/wildfly_cluster1.png[]

. Start Apache HTTPD server
+
[source, text]
----
docker run -d --name modcluster -p 80:80 <INSTRUCTOR_IP>:5000/mod_cluster
----
+
. Open http://dockerhost/mod_cluster_manager in your browser to see the empty console as:
+
.Apache HTTPD runing mod_cluster_manager interface
image::images/wildfly_cluster2.png[]
+
. Start the first WildFly instance:
+
[source, text]
----
docker run -d --name server1 --link db:db --link modcluster:modcluster <INSTRUCTOR_IP>:5000/ticketmonster-pgsql-wildfly
----
+
Besides linking the database container using `--link db:db`, we also link the ``modcluster'' container. This should be done rather quickly and if you now revisit the http://dockerhost/mod_cluster_manager/[mod_cluster_manager] in your browser, then you can see that the first server was registered with the loadbalancer:
+
.First WildFly instance registered with Load Balancer
image::images/wildfly_cluster3.png[]
+
. To make sure the Ticket Monster application is also running just visit http://dockerhost/ticket-monster and you will be presented with the Ticket Monster welcome screen.
+
.Clustered Ticket Monster Application
image::images/wildfly_cluster4.png[]
+
. Start as many WildFly instances as you want (and your computer memory can handle):
+
[source, text]
----
docker run -d --name server2 --link db:db --link modcluster:modcluster <INSTRUCTOR_IP>:5000/ticketmonster-pgsql-wildfly
docker run -d --name server3 --link db:db --link modcluster:modcluster <INSTRUCTOR_IP>:5000/ticketmonster-pgsql-wildfly
docker run -d --name server4 --link db:db --link modcluster:modcluster <INSTRUCTOR_IP>:5000/ticketmonster-pgsql-wildfly
----
+
. Stop some servers and check the application behavior:
+
[source, text]
----
docker stop server1
docker stop server3
----

TODO: Pick the parts that need to be described in more detail from https://goldmann.pl/blog/2013/10/07/wildfly-cluster-using-docker-on-fedora/

## Java EE Application on Docker Swarm Cluster

Docker Swarm solves one of the fundamental limitations of Docker where the containers could only run on a single Docker host. Docker Swarm is native clustering for Docker. It turns a pool of Docker hosts into a single, virtual host.

.Key Components of Docker Swarm
image::images/swarm1.png[]

*Swarm Manager*: Docker Swarm has a Master or Manager, that is a pre-defined Docker Host, and is a single point for all administration. Currently only a single instance of manager is allowed in the cluster. This is a SPOF for high availability architectures and additional managers will be allowed in a future version of Swarm with #598. TODO: ADD LINK.

*Swarm Nodes*: The containers are deployed on Nodes that are additional Docker Hosts. Each Swarm Node must be accessible by the manager, each node must listen to the same network interface (TCP port). Each node runs a node agent that registers the referenced Docker daemon, monitors it, and updates the discovery backend with the node’s status. The containers run on a node.

*Scheduler Strategy*: Different scheduler strategies (``binpack'', ``spread'' (default), and ``random'') can be applied to pick the best node to run your container. The default strategy optimizes the node for least number of running containers. There are multiple kinds of filters, such as constraints and affinity.  This should allow for a decent scheduling algorithm.

*Node Discovery Service*: By default, Swarm uses hosted discovery service, based on Docker Hub, using tokens to discover nodes that are part of a cluster. However etcd, consul, and zookeeper can be also be used for service discovery as well. This is particularly useful if there is no access to Internet, or you are running the setup in a closed network. A new discovery backend can be created as explained here. It would be useful to have the hosted Discovery Service inside the firewall and #660 will discuss this.

**Standard Docker API:** Docker Swarm serves the standard Docker API and thus any tool that talks to a single Docker host will seamlessly scale to multiple hosts now. That means if you were using shell scripts using Docker CLI to configure multiple Docker hosts, the same CLI would can now talk to Swarm cluster and Docker Swarm will then act as proxy and run it on the cluster.

There are lots of other concepts but these are the main ones.

. Create a Swarm cluster. The easiest way of using Swarm is, by using the official Docker image:
+
[source, text]
----
docker run swarm create
----
+
This command returns a <TOKEN> and is the unique cluster id. It will be used when creating master and nodes later. This cluster id is returned by the hosted discovery service on Docker Hub.
+
NOTE: Make sure to note this cluster id now as there is no means to list it later.
+
. Swarm is fully integrated with Docker Machine, and so is the easiest way to get started. Let's create a Swarm Master next:
+
[source, text]
----
docker-machine create -d virtualbox --swarm --swarm-master --swarm-discovery token://<TOKEN> swarm-master
----
+
The option "--swarm" configures the machine with Swarm, "--swarm-master" configures the created machine to be Swarm master. Make sure to replace cluster id after token:// with that obtained in the previous step. Swarm master creation talks to the hosted service on Docker Hub and informs that a master is created in the cluster.
+
. Connect to this newly created master and find some more information about it:
+
[source, text]
----
eval "$(docker-machine env swarm-master)"
docker info
----
+
NOTE: If you're on Windows, use the "docker-machine env swarm-master" command only and copy the output into an editor to replace all appearances of EXPORT with SET and issue the three commands at your command prompt, remove the quotes and all duplicate appearences of "/".
+
. Create Swarm nodes.
+
[source, text]
----
docker-machine create -d virtualbox --swarm --swarm-discovery token://<TOKEN> swarm-node-01
----
+
Node creation talks to the hosted service at Docker Hub and joins the previously created cluster. This is specified by --swarm-discovery token://... and specifying the cluster id obtained earlier.
+
. To make it a real cluster, let's create a second node:
+
[source, text]
----
docker-machine create -d virtualbox --swarm --swarm-discovery token://<TOKEN> swarm-node-02
----
+
. List all the nodes / Docker machines, that has been created so far.
+
[source, text]
----
TODO: ADD CODE
----
+
This shows the output as:
+
[source, text]
----
TODO: ADD CODE
----
+
The machines that are part of the cluster have the cluster’s name in the SWARM column, blank otherwise. For example, ``mymachine'' is a standalone machine where as all other machines are part of swarm-master cluster. The Swarm master is also identified by (master) in the SWARM column.
+
. Connect to the Swarm cluster and find some information about it:
+
[source, text]
----
eval "$(docker-machine env --swarm swarm-master)"
docker info
----
+
This shows the output as:
+
[source, text]
----
TODO: ADD CODE
----
+
There are 3 nodes – one Swarm master and 2 Swarm nodes. There is a total of 4 containers running in this cluster – one Swarm agent on master and each node, and there is an additional swarm-agent-master running on the master. This can be verified by connecting to the master and listing all the containers:
+
[source, text]
----
eval "$(docker-machine env swarm-master)"
docker info
----
+
. List nodes in the cluster with the following command:
+
[source, text]
----
docker run swarm list token://<TOKEN>
----
+
The complete cluster is in place now, and we need to deploy the Ticket Monster application to it.

Swarm takes care for the distribution of the deployments across the nodes. The only thing, we need to do is to deploy the application as explained already:

Double check, if the db instance is still running. If not, start it again.

[source, text]
----
docker start db
----

Next is the modcluster container:

[source, text]
----
docker start modcluster
----

And finally the server instances 1 to 3:

[source, text]
----
docker start server1
docker start server2
docker start server3
----

TODO: Is there any way to visualize containers in a cluster? Use Docker REST API?

## Starting Multiple Containers Using Docker Compose

Docker Compose script is only downloadable for OSX and Linux.

TODO: What are the exact steps to get it running on Windows?

Multiple containers, as in <<JavaEE_Application_Docker_Cluster>> can be easily started using Docker Compose, or Compose for short.

If you have some additional time, you can take this part of the lab:

http://blog.arungupta.me/docker-compose-orchestrate-containers-techtip77/

## Java EE Application on Kubernetes


## OpenShift v3 (Optional Part, No Windows)

If you are on a Mac or Linux system, you can also try out clustering with OpenShift V3 and Kubernetes. For this is an optional step in the lab, you can follow these separate instructions.

http://blog.arungupta.me/openshift-v3-getting-started-javaee7-wildfly-mysql/

## References

. JBoss and Docker: http://www.jboss.org/docker/
